#lang planet neil/sicp
(define (print tree)
  (cond ((not (pair? tree))
         (display tree)
         (display " "))
        (else (display " (")
              (map print tree)
              (display ") "))))
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(define (filter predictor? l)
  (cond ((null? l) nil)
        ((predictor? (car l))
         (cons (car l)
               (filter predictor? (cdr l))))
        (else (filter predictor? (cdr l)))))
(define (enumerate-interval start end)
  (if (> start end)
      nil
      (cons start (enumerate-interval (+ 1 start) end))))
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
(define empty-board nil)
(define (safe? k ps)
  (if (null? ps) #t
      (if (not (null? (filter (lambda (e) (= (cadr (car ps)) (cadr e))) (cdr ps))))
          #f
          (null? (filter (lambda (e) (= (abs (- (car (car ps)) (car e))) (abs (- (cadr (car ps)) (cadr e)))))
                         (cdr ps))))))
(define (adjoin-position nr k qs)
  (cons (list k nr) qs))
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (let ((r (safe? k positions))) r))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(print (queens 8))
